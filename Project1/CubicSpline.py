import matplotlib.pyplot as plt
from numpy import *
import scipy.linalg as sl
from greville_abscissae import greville_abscissae
from vandermonde import vandermonde
from basis_function import basis_function

"""
@author: Mika Persson & Viktor Sambergs
"""


class CubicSpline:
    """
    Class for creating and plotting a cubic spline
    """

    def __init__(self, control, knots):
        """
        Constructs a cubic spline according to the given control points and knots
        :param control: (array)
        :param knots: (array)
        """

        self.control_points = array(control)

        self.knot_points = array(knots)

        size = 10000
        self.su = empty((size, 2))

        self.su = array([self(i*len(self.knot_points) / (size - 1)) for i in range(size)])

    def get_spline(self):
        """
        Returns the spline
        :return: (array)
        """

        return self.su

    def __call__(self, u):  # follows 1.9 summary
        """
        Computes and returns the value of the spline at 'u'
        :param u: (float)
        :return: (float)
        """

        # Find hot interval. Index of the element with higher value (than u) - 1.
        I = (self.knot_points > u).argmax() - 1

        if I == -1:  # for the case u_K <= u
            return self.control_points[-1]

        # Select 4 control points d_{I-2} to d_{I+1}
        four_control = self.control_points[I-2:I+2].copy()

        # Run blossom algorithm (de Boor)
        s = self.blossoms(four_control, self.knot_points, I, u)  # d[u,u,u] = s(u)
        return s

    def blossoms(self, c, k, I, u, depth=2):
        """
        Evaluates s(u) in accordance with De Boor's algorithm (section 1.7 in the slides)
        :param c: (array) Array of "hot" control points of shape (4,)
        :param k: (array) knot points of shape (#knot points + 4,)
        :param I: (int) Index of interval that contains u
        :param u: (int) position in [u_0, u_K]
        :param depth: (int) how deep we do the recursion
        :return: (array) the value of the spline at the knot point u, the shape is (2,)
        """

        # Size of array of "hot control points" (number of elements in a column in slide 8)
        size = c.shape[0]

        # If the size is 1 c is s(u) (d[u,u,u])
        if size == 1:
            return c

        # Array for storing new control points
        # Should be size (3,2), then (2,2), lastly (1,2)
        newcontrolpoints = zeros((size - 1, 2))

        for i in range(1, size):
            # At first call operations are performed 3 times, then 2, then one.

            # New control point at index i is constructed from previous points at index i and i+1

            # Old control points have knot points spanning over a range size-1 (4 indices, 3 indices and so on).
            r = size - 1

            # Max index for knotpoints is I+i, min is (I+i)-range.
            maxindex = I + i
            minindex = maxindex - r

            # Leftmost- (u_{(I+i)-r}) and rightmost knot (u_{I+i}) for construction of alpha(u)
            urightmostknot = k[maxindex]
            uleftmostknot = k[minindex]

            alphau = (urightmostknot - u) / (urightmostknot - uleftmostknot)

            # Vector of new control points is filled.
            newelement = alphau * c[i - 1] + (1 - alphau) * c[i]

            newcontrolpoints[i - 1] = newelement

        # For every call the size of newcontrolpoints is smaller until s(u) is returned.
        if depth == 0:
            return newcontrolpoints[0]
        else:
            depth -= 1
            return self.blossoms(newcontrolpoints, k, I, u, depth)

    def interpolate(self, x, y):
        """
        Computes the control points for a spline interpolated through the coordinates (x,y)
        :param x: (array)
        :param y: (array)
        :return: (array)
        """

        vander = vandermonde(self.knot_points)
        dx = sl.solve(vander, x)
        dy = sl.solve(vander, y)

        return array([dx, dy]).T

    def plot_interpolated(self, inter_control, x, y):
        """
        Plots the interpolated spline and the interpolation points (x, y)
        :param inter_control: calculated control points
        :param x: (array) x-coordinates
        :param y: (array) y-coordinates
        :return: None
        """

    def plot(self):
        """
        Plot the cubic spline (self.s_u), its control polygon (generated by (self.control_points)
        and the de Boor points (self.control_points)
        :return: None
        """

        plt.plot(self.su[:, 0], self.su[:, 1], 'b', label="cubic spline")  # spline
        plt.plot(self.control_points[:, 0], self.control_points[:, 1], '-.r', label="control polygon")  # control polygon
        plt.scatter(self.control_points[:, 0], self.control_points[:, 1], color='red')  # de Boor points

        plt.title("Cubic Spline")
        plt.legend()
        plt.xlabel("x")
        plt.ylabel("y")
        plt.grid()
        plt.show()

    def plot_spline_blossoms(self, I):
        """
        Plots the i:th basis function together with the blossoms d[u,u,u_i], d[u,u_{i-1},u_i] and d[u_{i-2},u_{i-1},u_i]
        :param I: (int)
        :return: None
        """

        # Find blossoms ONLY WORKS FOR I>=2
        four_control = self.control_points[I-2:I+2].copy()                      # 4 "hot" knot points
        first_blossom = four_control[0]                                         # d[u_{i-2},u_{i-1},u_i]
        second_blossom = self.blossoms(four_control, self.knot_points, I, I, 0) # d[u,u_{i-1},u_i]
        third_blossom = self.blossoms(four_control, self.knot_points, I, I, 1)  # d[u,u,u_i]

        print(first_blossom)
        print(second_blossom)
        print(third_blossom)

        plt.plot(self.su[:, 0], self.su[:, 1], 'b', label="cubic spline")
        plt.title("Cubic spline and blossoms for knot point {}".format("$u_{}$".format(I)))
        plt.plot(self.control_points[:, 0], self.control_points[:, 1], '-.r',
                 label="control polygon")  # control polygon
        plt.scatter(self.control_points[:, 0], self.control_points[:, 1], color='red')  # de Boor points
        plt.scatter(first_blossom[0], first_blossom[1], label="d[$u_{},u_{},u_{}$]".format({I-2}, {I-1},{I}))
        plt.scatter(first_blossom[0], first_blossom[1], label="d[$u,u_{},u_{}$]".format({I - 1}, {I}))
        plt.scatter(first_blossom[0], first_blossom[1], label="d[$u,u,u_{}$]".format({I}))
        plt.legend()
        plt.grid()
        plt.show()
